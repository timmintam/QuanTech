from pyscf import gto, scf, ao2mo
import numpy as np

coordinates=np.array([0.0,1.0])

# define the molecule
mol_h2 = gto.M(
    atom = [['H',(coordinates[0], 0.0, 0.0)], 
            ['H',(coordinates[1], 0.0, 0.0)]],
    basis = 'sto3g',
    charge = 0,
    spin = 0,
    symmetry = true,
)

'''
kernel: the SCF driver.
    Args:
        mf : an instance of SCF class
            mf object holds all parameters to control SCF.  One can modify its
            member functions to change the behavior of SCF.  The member
            functions which are called in kernel are
            | mf.get_init_guess
            | mf.get_hcore
            | mf.get_ovlp
            | mf.get_veff
            | mf.get_fock
            | mf.get_grad
            | mf.eig
            | mf.get_occ
            | mf.make_rdm1
            | mf.energy_tot
            | mf.dump_chk
    Kwargs:
        conv_tol : float
            converge threshold.
        conv_tol_grad : float
            gradients converge threshold.
        dump_chk : bool
            Whether to save SCF intermediate results in the checkpoint file
        dm0 : ndarray
            Initial guess density matrix.  If not given (the default), the kernel
            takes the density matrix generated by ``mf.get_init_guess``.
        callback : function(envs_dict) => None
            callback function takes one dict as the argument which is
            generated by the builtin function :func:`locals`, so that the
            callback function can access all local variables in the current
            envrionment.
    Returns:
        A list :   scf_conv, e_tot, mo_energy, mo_coeff, mo_occ
        scf_conv : bool
            True means SCF converged
        e_tot : float
            Hartree-Fock energy of last iteration
        mo_energy : 1D float array
            Orbital energies.  Depending the eig function provided by mf
            object, the orbital energies may NOT be sorted.
        mo_coeff : 2D array
            Orbital coefficients.
        mo_occ : 1D array
            Orbital occupancies.  The occupancies may NOT be sorted from large
            to small.
    Examples:
    >>> from pyscf import gto, scf
    >>> mol = gto.M(atom='H 0 0 0; H 0 0 1.1', basis='cc-pvdz')
    >>> conv, e, mo_e, mo, mo_occ = scf.hf.kernel(scf.hf.SCF(mol), dm0=numpy.eye(mol.nao_nr()))
    >>> print('conv = %s, E(HF) = %.12f' % (conv, e))
    conv = True, E(HF) = -1.081170784378
'''

# Harttree-Fock calculations
rhf_h2 = scf.RHF(mol_h2)
rhf_h2.kernel()

print(rhf_h2.e_tot)

dm1 = rhf_h2.make_rdm1()

hcore_ao = mol_h2.intor_symmetric('int1e_kin') + mol_h2.intor_symmetric('int1e_nuc')
hcore_mo = np.einsum('pi,pq,qj->ij', rhf_h2.mo_coeff, hcore_ao, rhf_h2.mo_coeff)
eri_4fold_ao = mol_h2.intor('int2e_sph')#, aosym=8)
eri_4fold_mo = ao2mo.incore.full(eri_4fold_ao, rhf_h2.mo_coeff)

orb = rhf_h2.mo_coeff
eri_4fold = ao2mo.kernel(mol_h2, orb, compact=True)
print('MO integrals (ij|kl) with 4-fold symmetry i>=j, k>=l have shape %s' %
      str(eri_4fold.shape))

print(eri_4fold)


mol1 = gto.M(atom='H 0 1 0; H 0 0 1', basis='sto3g')
orb = mol1.RHF().run().mo_coeff
eri1 = ao2mo.kernel(mol1, orb)
print(eri1)

# monkey patching to override python function to modify a part of the pyscf routine
# oss@zurich.ibm.com

